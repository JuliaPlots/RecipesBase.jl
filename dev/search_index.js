var documenterSearchIndex = {"docs":
[{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"using Plots, Random\nRandom.seed!(100)\ndefault(legend = :topleft, markerstrokecolor = :auto, markersize = 6)","category":"page"},{"location":"types/#Recipe-Types-1","page":"Recipe Types","title":"Recipe Types","text":"","category":"section"},{"location":"types/#Overview-1","page":"Recipe Types","title":"Overview","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"There are four main types of recipes which are determined by the signature of the @recipe macro.","category":"page"},{"location":"types/#User-Recipes-1","page":"Recipe Types","title":"User Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(custom_arg_1::T, custom_arg_2::S, ...; ...)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"tip: Tip\n@userplot provides a convenient way to create a custom type to dispatch on and defines custom plotting functions.@userplot MyPlot\n@recipe function f(mp::MyPlot; ...)\n    ...\nendNow we can plot with:myplot(args...; kw...)\nmyplot!(args...; kw...)","category":"page"},{"location":"types/#Type-Recipes-1","page":"Recipe Types","title":"Type Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{T}, val::T) where T","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"compat: Compat\nWith RecipesBase 1.0 type recipes are aware of the current axis (:x, :y, :z).@recipe function f(::Type{MyType}, val::MyType)\n    guide --> \"My Guide\"\n    ...\nendThis only sets the guide for the axes with MyType. For more complex type recipes the current axis letter can be accessed in @recipe with plotattributes[:letter].","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"compat: Compat\nWith RecipesBase 1.0 type recipes of the form@recipe function f(::Type{T}, val::T) where T <: AbstractArray{MyType}for AbstractArrays of custom types are supported too.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"info: Info\nUser recipes and type recipes must return eitheran AbstractArray{<:V} where V is a valid type,\ntwo functions, or\nnothingA valid type is either a Plots datapoint or a type that can be handled by another user recipe or type recipe. Plots datapoints are all subtypes of Union{AbstractString, Missing} and Union{Number, Missing}.If two functions are returned the former should tell Plots how to convert from T to a datapoint and the latter how to convert from datapoint to string for tick label formatting.","category":"page"},{"location":"types/#Plot-Recipes-1","page":"Recipe Types","title":"Plot Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:myplotrecipename}}, plt::AbstractPlot; ...)","category":"page"},{"location":"types/#Series-Recipes-1","page":"Recipe Types","title":"Series Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:myseriesrecipename}}, x, y, z; ...)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"tip: Tip\nThe @shorthands macro provides a convenient way to define plotting functions for custom plot recipes or series recipes.@shorthands myseriestype\n@recipe function f(::Type{Val{:myseriestype}}, x, y, z; ...)\n    ...\nendThis allows to plot with:myseriestype(args...; kw...)\nmyseriestype!(args...; kw...)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"warning: Warning\nPlot recipes and series recipes have to set the seriestype attribute.","category":"page"},{"location":"types/#User-Recipes-2","page":"Recipe Types","title":"User Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"User recipes are called early in the processing pipeline and allow designing custom visualizations.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(custom_arg_1::T, custom_arg_2::S, ...; ...)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"We have already seen an example for a user recipe in the syntax section above. User recipes can also be used to define a custom visualization without necessarily wishing to plot a custom type. For this purpose we can create a type to dispatch on. The @userplot macro is a convenient way to do this.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@userplot MyPlot","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"expands to","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"mutable struct MyPlot\n    args\nend\nexport myplot, myplot!\nmyplot(args...; kw...) = plot(MyPlot(args); kw...)\nmyplot!(args...; kw...) = plot!(MyPlot(args); kw...)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"To check args type, define a struct with type parameters.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@userplot struct MyPlot{T<:Tuple{AbstractVector}}\n    args::T\nend","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"We can use this to define a user recipe for a pie plot.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"# defines mutable struct `UserPie` and sets shorthands `userpie` and `userpie!`\n@userplot UserPie\n@recipe function f(up::UserPie)\n    y = up.args[end] # extract y from the args\n    # if we are passed two args, we use the first as labels\n    labels = length(up.args) == 2 ? up.args[1] : eachindex(y)\n    framestyle --> :none\n    aspect_ratio --> true\n    s = sum(y)\n    θ = 0\n    # add a shape for each piece of pie\n    for i in 1:length(y)\n        # determine the angle until we stop\n        θ_new = θ + 2π * y[i] / s\n        # calculate the coordinates\n        coords = [(0.0, 0.0); Plots.partialcircle(θ, θ_new, 50)]\n        @series begin\n            seriestype := :shape\n            label --> string(labels[i])\n            coords\n        end\n        θ = θ_new\n    end\n    # we already added all shapes in @series so we don't want to return a series\n    # here. (Technically we are returning an empty series which is not added to\n    # the legend.)\n    primary := false\n    ()\nend","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Now we can just use the recipe like this:","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"userpie('A':'D', rand(4))","category":"page"},{"location":"types/#Type-Recipes-2","page":"Recipe Types","title":"Type Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Type recipes define one-to-one mappings from custom types to something Plots supports","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{T}, val::T) where T","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Suppose we have a custom wrapper for vectors.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"struct MyWrapper\n    v::Vector\nend","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"We can tell Plots to just use the wrapped vector for plotting in a type recipe.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe f(::Type{MyWrapper}, mw::MyWrapper) = mw.v","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Now Plots knows what to do when it sees a MyWrapper.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"mw = MyWrapper(cumsum(rand(10)))\nplot(mw)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Due to the recursive application of type recipes they even compose automatically.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"struct MyOtherWrapper\n    w\nend\n\n@recipe f(::Type{MyOtherWrapper}, mow::MyOtherWrapper) = mow.w\n\nmow = MyOtherWrapper(mw)\nplot(mow)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"If we want an element-wise conversion of custom types we can define a conversion function to a type that Plots supports (Real, AbstractString) and a formatter for the tick labels. Consider the following simple time type.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"struct MyTime\n    h::Int\n    m::Int\nend\n\n# show e.g. `MyTime(1, 30)` as \"01:30\"\ntime_string(mt) = join((lpad(string(c), 2, \"0\") for c in (mt.h, mt.m)), \":\")\n# map a `MyTime` object to the number of minutes that have passed since midnight.\n# this is the actual data Plots will use.\nminutes_since_midnight(mt) = 60 * mt.h + mt.m\n# convert the minutes passed since midnight to a nice string showing `MyTime`\nformatter(n) = time_string(MyTime(divrem(n, 60)...))\n\n# define the recipe (it must return two functions)\n@recipe f(::Type{MyTime}, mt::MyTime) = (minutes_since_midnight, formatter)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Now we can plot vectors of MyTime automatically with the correct tick labelling. DateTimes and Chars are implemented with such a type recipe in Plots for example.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"times = MyTime.(0:23, rand(0:59, 24))\nvals = log.(1:24)\n\nplot(times, vals)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Again everything composes nicely.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"plot(MyWrapper(vals), MyOtherWrapper(times))","category":"page"},{"location":"types/#Plot-Recipes-2","page":"Recipe Types","title":"Plot Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Plot recipes are called after all input data is processed by type recipes but before the plot and subplots are set-up. They allow to build series with custom layouts and set plot-wide attributes.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:myplotrecipename}}, plt::AbstractPlot; ...)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Plot recipes define a new series type. They are applied after type recipes. Hence, standard Plots types can be assumed for input data :x, :y and :z in plotattributes. Plot recipes can access plot and subplot attributes before they are processed, for example to build layouts. Both, plot recipes and series recipes must change the series type. Otherwise we get a warning that we would run into a StackOverflow error.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"We can define a seriestype :yscaleplot, that automatically shows data with a linear y scale in one subplot and with a logarithmic yscale in another one.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:yscaleplot}}, plt::AbstractPlot)\n    x, y = plotattributes[:x], plotattributes[:y]\n    layout := (1, 2)\n    for (i, scale) in enumerate((:linear, :log))\n        @series begin\n            title --> string(scale, \" scale\")\n            seriestype := :path\n            subplot := i\n            yscale := scale\n        end\n    end\nend","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"We can call it with plot(...; ..., seriestype = :yscaleplot) or we can define a shorthand with the @shorthands macro.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@shorthands myseries","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"expands to","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"export myseries, myseries!\nmyseries(args...; kw...) = plot(args...; kw..., seriestype = :myseries)\nmyseries!(args...; kw...) = plot!(args...; kw..., seriestype = :myseries)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"So let's try the yscaleplot plot recipe.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@shorthands yscaleplot\n\nyscaleplot((1:10).^2)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Magically the composition with type recipes works again.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"yscaleplot(MyWrapper(times), MyOtherWrapper((1:24).^2))","category":"page"},{"location":"types/#Series-Recipes-2","page":"Recipe Types","title":"Series Recipes","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Series recipes are applied recursively until the current backend supports a series type. They are used for example to convert the input data of a bar plot to the coordinates of the shapes that define the bars.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:myseriesrecipename}}, x, y, z; ...)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"If we want to call the userpie recipe with a custom type we run into errors.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"userpie(MyWrapper(rand(4)))","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"ERROR: MethodError: no method matching keys(::MyWrapper)\nStacktrace:\n [1] eachindex(::MyWrapper) at ./abstractarray.jl:209","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Furthermore, if we want to show multiple pie charts in different subplots, we don't get what we expect either","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"userpie(rand(4, 2), layout = 2)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"We could overcome these issues by implementing the required AbstractArray methods for MyWrapper (instead of the type recipe) and by more carefully dealing with different series in the userpie recipe. However, the simpler approach is writing the pie recipe as a series recipe and relying on Plots' processing pipeline.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:seriespie}}, x, y, z)\n    framestyle --> :none\n    aspect_ratio --> true\n    s = sum(y)\n    θ = 0\n    for i in eachindex(y)\n        θ_new = θ + 2π * y[i] / s\n        coords = [(0.0, 0.0); Plots.partialcircle(θ, θ_new, 50)]\n        @series begin\n            seriestype := :shape\n            label --> string(x[i])\n            x := first.(coords)\n            y := last.(coords)\n        end\n        θ = θ_new\n    end\nend\n@shorthands seriespie","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Here we use the already processed values x and y to calculate the shape coordinates for each pie piece, update x and y with these coordinates and set the series type to :shape.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"seriespie(rand(4))","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"This automatically works together with type recipes ...","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"seriespie(MyWrapper(rand(4)))","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"... or with layouts","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"seriespie(rand(4, 2), layout = 2)","category":"page"},{"location":"types/#Remarks-1","page":"Recipe Types","title":"Remarks","text":"","category":"section"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Plot recipes and series recipes are actually very similar. In fact, a pie recipe could be also implemented as a plot recipe by acessing the data through plotattributes.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:plotpie}}, plt::AbstractPlot)\n    y = plotattributes[:y]\n    labels = plotattributes[:x]\n    framestyle --> :none\n    aspect_ratio --> true\n    s = sum(y)\n    θ = 0\n    for i in 1:length(y)\n        θ_new = θ + 2π * y[i] / s\n        coords = [(0.0, 0.0); Plots.partialcircle(θ, θ_new, 50)]\n        @series begin\n            seriestype := :shape\n            label --> string(labels[i])\n            x := first.(coords)\n            y := last.(coords)\n        end\n        θ = θ_new\n    end\nend\n@shorthands plotpie\n\nplotpie(rand(4, 2), layout = (1, 2))","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"The series recipe syntax is just a little nicer in this case.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"info: Info\nHere's subtle difference between these recipe types: Plot recipes are applied in any case while series are only applied if the backend does not support the series type natively.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"Let's try it the other way around and implement our yscaleplot recipe as a series recipe.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"@recipe function f(::Type{Val{:yscaleseries}}, x, y, z)\n    layout := (1, 2)\n    for (i, scale) in enumerate((:linear, :log))\n        @series begin\n            title --> string(scale, \" scale\")\n            seriestype := :path\n            subplot := i\n            yscale := scale\n        end\n    end\nend\n@shorthands yscaleseries","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"That looks a little nicer than the plot recipe version as well. Let's try to plot.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"yscaleseries((1:10).^2)","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"MethodError: Cannot `convert` an object of type Int64 to an object of type Plots.Subplot{Plots.GRBackend}\nClosest candidates are:\n  convert(::Type{T}, !Matched::T) where T at essentials.jl:168\n  Plots.Subplot{Plots.GRBackend}(::Any, !Matched::Any, !Matched::Any, !Matched::Any, !Matched::Any, !Matched::Any, !Matched::Any, !Matched::Any) where T<:RecipesBase.AbstractBackend at /home/daniel/.julia/packages/Plots/rNwM4/src/types.jl:88","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"That is because the plot and subplots have already been built before the series recipe is applied.","category":"page"},{"location":"types/#","page":"Recipe Types","title":"Recipe Types","text":"tip: Tip\nFor everything that modifies plot-wide attributes plot recipes have to be used, otherwise series recipes are recommended.","category":"page"},{"location":"api/#","page":"Library","title":"Library","text":"Modules = [RecipesBase]","category":"page"},{"location":"api/#RecipesBase.@recipe-Tuple{Expr}","page":"Library","title":"RecipesBase.@recipe","text":"This handy macro will process a function definition, replace --> commands, and then add a new version of RecipesBase.apply_recipe for dispatching on the arguments.\n\nThis functionality is primarily geared to turning user types and settings into the data and attributes that describe a Plots.jl visualization.\n\nSet attributes using the --> command, and return a comma separated list of arguments that should replace the current arguments.\n\nAn example:\n\nusing RecipesBase\n\n# Our custom type that we want to display\ntype T end\n\n@recipe function plot{N<:Integer}(t::T, n::N = 1; customcolor = :green)\n    markershape --> :auto, :require\n    markercolor --> customcolor, :force\n    xrotation --> 5\n    zrotation --> 6, :quiet\n    rand(10,n)\nend\n\n# ---------------------\n\n# Plots will be the ultimate consumer of our recipe in this example\nusing Plots; gr()\n\n# This call will implicitly call `RecipesBase.apply_recipe` as part of the Plots\n# processing pipeline (see the Pipeline section of the Plots documentation).\n# It will plot 5 line plots, all with black circles for markers.\n# The markershape argument must be supported, and the zrotation argument's warning\n# will be suppressed.  The user can override all arguments except markercolor.\nplot(T(), 5; customcolor = :black, shape=:c)\n\nIn this example, we see lots of the machinery in action.  We create a new type T which we will use for dispatch, and an optional argument n, which will be used to determine the number of series to display.  User-defined keyword arguments are passed through, and the --> command can be trailed by flags:\n\nquiet:   Suppress unsupported keyword warnings\nrequire: Error if keyword is unsupported\nforce:   Don't allow user override for this keyword\n\n\n\n\n\n","category":"macro"},{"location":"api/#RecipesBase.@series-Tuple{Expr}","page":"Library","title":"RecipesBase.@series","text":"Meant to be used inside a recipe to add additional RecipeData objects to the list:\n\n@recipe function f(::T)\n    # everything get this setting\n    linecolor --> :red\n\n    @series begin\n        # this setting is only for this series\n        fillcolor := :green\n\n        # return the args, just like in recipes\n        rand(10)\n    end\n\n    # this is the main series... though it can be skipped by returning nothing.\n    # note: a @series block returns nothing\n    rand(100)\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#RecipesBase.@shorthands-Tuple{Symbol}","page":"Library","title":"RecipesBase.@shorthands","text":"@shorthands(funcname::Symbol)\n\nDefines and exports shorthand plotting method definitions ($funcname and $funcname!). Pass the series type (as a symbol) to the macro.\n\nExamples\n\n# define some series type\n@recipe function f(::Type{Val{:myseriestype}}, x, y)\n    # some implementation here\nend\n# docstrings are forwarded\n\"\"\"\n    myseriestype(x, y)\nPlot my series type!\n\"\"\"\n@shorthands myseriestype\n\n\n\n\n\n","category":"macro"},{"location":"api/#RecipesBase.@userplot-Tuple{Any}","page":"Library","title":"RecipesBase.@userplot","text":"You can easily define your own plotting recipes with convenience methods:\n\n@userplot GroupHist\n\n@recipe function f(gh::GroupHist)\n    # set some attributes, add some series, using gh.args as input\nend\n# now you can plot like:\ngrouphist(rand(1000,4))\n\n\n\n\n\n","category":"macro"},{"location":"api/#RecipesBase.recipetype-Tuple{Any,Vararg{Any,N} where N}","page":"Library","title":"RecipesBase.recipetype","text":"recipetype(s, args...)\n\nUse this function to refer to type recipes by their symbol, without taking a dependency.\n\nExample\n\nimport RecipesBase: recipetype\nrecipetype(:groupedbar, 1:10, rand(10, 2))\n\ninstead of\n\nimport StatsPlots: GroupedBar\nGroupedBar((1:10, rand(10, 2)))\n\n\n\n\n\n","category":"method"},{"location":"#RecipesBase.jl-1","page":"Home","title":"RecipesBase.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Author: Thomas Breloff (@tbreloff)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RecipesBase is a lightweight Package without dependencies that allows to define custom visualizations with the @recipe macro.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Package developers and users can define recipes to tell Plots.jl how to plot custom types without depending on it. Furthermore, recipes can be used for complex visualizations and new series types. Plots, for example, uses recipes internally to define histograms or bar plots. StatsPlots.jl and GraphRecipes.jl extend Plots functionality for statistical plotting and visualization of graphs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RecipesBase exports the @recipe macro which provides a nice syntax for defining plot recipes. Under the hood @recipe defines a new method for RecipesBase.apply_recipe which is called recursively in Plots at different stages of the argument processing pipeline. This way other packages can communicate with Plots, i.e. define custom plotting recipes, only depending on RecipesBase. Furthermore, the convenience macros @series, @userplot and @shorthands are exported by RecipesBase.","category":"page"},{"location":"internals/#RecipesBase-1","page":"Internals","title":"RecipesBase","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The @recipe macro defines a new method for RecipesBase.apply_recipe.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"@recipe function f(args...; kwargs...)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"defines","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"RecipesBase.apply_recipe(plotattributes, args...; kwargs...)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"returning a Vector{RecipeData} where RecipeData holds the plotattributes Dict and the arguments returned in @recipe or in @series.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"struct RecipeData\n    plotattributes::AbstractDict{Symbol,Any}\n    args::Tuple\nend","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"This function sets and overwrites entries in plotattributes and possibly adds new series.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"attr --> val translates to haskey(plotattributes, :attr) || plotattributes[:attr] = val\nattr := val sets plotattributes[:attr] = val.\n@series allows to add new series within @recipe. It copies plotattributes from @recipe, applies the replacements defined in its code block and returns corresponding new RecipeData object.   !!! info       @series have to be defined as a code block with begin and end statements.       julia       @series begin           ...       end","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"So RecipesBase.apply_recipe(plotattributes, args...; kwargs...) returns a Vector{RecipeData}. Plots can then recursively apply it again on the plotattributes and args of the elements of this vector, dispatching on a different signature.","category":"page"},{"location":"internals/#Plots-1","page":"Internals","title":"Plots","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The standard plotting commands","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"plot(args...; plotattributes...)\nplot!(args...; plotattributes...)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"and shorthands like scatter or bar call the core internal plotting function Plots._plot!.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Plots._plot!(plt::Plot, plotattributes::AbstractDict{Symbol, Any}, args::Tuple)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"In the following we will go through the major steps of the preprocessing pipeline implemented in Plots._plot!.","category":"page"},{"location":"internals/#Preprocess-plotattributes-1","page":"Internals","title":"Preprocess plotattributes","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Before Plots._plot! is called and after each recipe is applied, preprocessArgs!  preprocesses the plotattributes Dict. It replaces aliases, expands magic arguments, and converts some attribute types.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"lc = nothing is replaced by linecolor = RGBA(0, 0, 0, 0).\nmarker = (:red, :circle, 8) expands to markercolor = :red, markershape = :circle and markersize = 8.","category":"page"},{"location":"internals/#Process-User-Recipes-1","page":"Internals","title":"Process User Recipes","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"In the first step, _process_userrecipe is called.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"kw_list = _process_userrecipes(plt, plotattributes, args)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"It converts the user-provided plotattributes to a vector of RecipeData. It recursively applies RecipesBase.apply_recipe on the fields of the first element of the RecipeData vector and prepends the resulting RecipeData vector to it. If the args of an element are empty, it extracts plotattributes and adds it to a Vector of Dicts kw_list. When all RecipeData elements are fully processed, kw_list is returned.","category":"page"},{"location":"internals/#Process-Type-Recipes-1","page":"Internals","title":"Process Type Recipes","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"After user recipes are processed, at some point in the recursion above args is of the form (y, ), (x, y) or (x, y, z). Plots defines recipes for these signatures. The two argument version, for example, looks like this.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"@recipe function f(x, y)\n    did_replace = false\n    newx = _apply_type_recipe(plotattributes, x)\n    x === newx || (did_replace = true)\n    newy = _apply_type_recipe(plotattributes, y)\n    y === newy || (did_replace = true)\n    if did_replace\n        newx, newy\n    else\n        SliceIt, x, y, nothing\n    end\nend","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"It recursively calls _apply_type_recipe on each argument until none of the arguments is replaced. _apply_type_recipe applies the type recipe with the corresponding signature and for vectors it tries to apply the recipe element-wise. When no argument is changed by _apply_type_recipe, the fallback SliceIt recipe is applied, which adds the data to plotattributes and returns RecipeData with empty args.","category":"page"},{"location":"internals/#Process-Plot-Recipes-1","page":"Internals","title":"Process Plot Recipes","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"At this stage all arguments have been processed to something Plots supports. In _plot! we have a Vector{Dict} kw_list with an entry for each series and already populated :x, :y and :z keys. Now _process_plotrecipe is called until all plot recipes are processed.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"still_to_process = kw_list\nkw_list = KW[]\nwhile !isempty(still_to_process)\n    next_kw = popfirst!(still_to_process)\n    _process_plotrecipe(plt, next_kw, kw_list, still_to_process)\nend","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"If no series type is set in the Dict, _process_plotrecipe pushes it to kw_list and returns. Otherwise it tries to call RecipesBase.apply_recipe with the plot recipe signature. If there is a method for this signature and the seriestype has changed by applying the recipe, the new plotattributes are appended to still_to_process. If there is no method for the current plot recipe signature, we append the current Dict to kw_list and rely on series recipe processing.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"After all plot recipes have been applied, the plot and subplots are set-up.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"_plot_setup(plt, plotattributes, kw_list)\n_subplot_setup(plt, plotattributes, kw_list)","category":"page"},{"location":"internals/#Process-Series-Recipes-1","page":"Internals","title":"Process Series Recipes","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"We are almost finished. Now the series defaults are populated and _process_seriesrecipe is called for each series .","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"for kw in kw_list\n    # merge defaults\n    series_attr = Attr(kw, _series_defaults)\n    _process_seriesrecipe(plt, series_attr)\nend","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"If the series type is natively supported by the backend, we finalize processing and pass the series along to the backend. Otherwise, the series recipe for the current series type is applied and _process_seriesrecipe is called again for the plotattributes in each returned RecipeData object. Here we have to check again that the series type changed. Due to this recursive processing, complex series types can be built up by simple blocks. For example if we add an @show st in _process_seriesrecipe and plot a histogram, we go through the following series types:","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"plot(histogram(randn(1000)))","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"st = :histogram\nst = :barhist\nst = :barbins\nst = :bar\nst = :shape","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"using Plots # hide\nplot(histogram(randn(1000))) #hide","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"using Plots, Random\nRandom.seed!(100)\ndefault(legend = :topleft, markerstrokecolor = :auto, markersize = 6)","category":"page"},{"location":"syntax/#Recipes-Syntax-1","page":"Recipe Syntax","title":"Recipes Syntax","text":"","category":"section"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"The syntax in the @recipe macro is best explained using an example. Suppose, we have a custom type storing the results of a simulation x and y and a measure ε for the maximum error in y.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"struct Result\n    x::Vector{Float64}\n    y::Vector{Float64}\n    ε::Vector{Float64}\nend","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"If we want to plot the x and y values of such a result with an error band given by ε, we could run something like","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"res = Result(1:10, cumsum(rand(10)), cumsum(rand(10)) / 5)\n\nusing Plots\n\n# plot the error band as invisible line with fillrange\nplot(\n    res.x,\n    res.y .+ res.ε,\n    xlabel = \"x\",\n    ylabel = \"y\",\n    fill = (res.y .- res.ε, :lightgray, 0.5),\n    linecolor = nothing,\n    primary = false, # no legend entry\n)\n\n# add the data to the plots\nplot!(res.x, res.y, marker = :diamond)","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"Instead of typing this plot command over and over for different results we can define a user recipe to tell Plots what to do with input of the type Result. Here is an example for such a user recipe with the additional feature to highlight datapoints with a maximal error above a certain threshold ε_max.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"@recipe function f(r::Result; ε_max = 0.5)\n    # set a default value for an attribute with `-->`\n    xlabel --> \"x\"\n    yguide --> \"y\"\n    markershape --> :diamond\n    # add a series for an error band\n    @series begin\n        # force an argument with `:=`\n        seriestype := :path\n        # ignore series in legend and color cycling\n        primary := false\n        linecolor := nothing\n        fillcolor := :lightgray\n        fillalpha := 0.5\n        fillrange := r.y .- r.ε\n        # ensure no markers are shown for the error band\n        markershape := :none\n        # return series data\n        r.x, r.y .+ r.ε\n    end\n    # get the seriescolor passed by the user\n    c = get(plotattributes, :seriescolor, :auto)\n    # highlight big errors, otherwise use the user-defined color\n    markercolor := ifelse.(r.ε .> ε_max, :red, c)\n    # return data\n    r.x, r.y\nend","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"Let's walk through this recipe step by step. First, the function signature in the recipe definition determines the recipe type, in this case a user recipe. The function name f in is irrelevant and can be replaced by any other function name. @recipe does not use it. In the recipe body we can set default values for Plots attributes.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"attr --> val","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"This will set attr to val unless it is specified otherwise by the user in the plot command.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"plot(args...; kw..., attr = otherval)","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"Similarly we can force an attribute value with :=.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"attr := val","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"This overwrites whatever the user passed to plot for attr and sets it to val.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"tip: Tip\nIt is strongly recommended to avoid using attribute aliases in recipes as this might lead to unexpected behavior in some cases. In the recipe above xlabel is used as aliases for xguide. When the recipe is used Plots will show a warning and hint to the default attribute name. They can also be found in the attribute tables under http://docs.juliaplots.org/latest/attributes/.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"We use the @series macro to add a new series for the error band to the plot. Within an @series block we can use the same syntax as above to force or set default values for attributes.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"In @recipe we have access to plotattributes. This is an AbstractDict storing the attributes that have been already processed at the current stage in the Plots pipeline. For user recipes, which are called early in the pipeline, this mostly contains the keyword arguments provided by the user in the plot command. In our example we want to highlight data points with an error above a certain threshold by changing the marker color. For all other data points we set the marker color to whatever is the default or has been provided as keyword argument. We can do this by getting the seriescolor from plotattributes and defaulting to auto if it has not been specified by the user.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"Finally, in both, @recipes and @series blocks we return the data we wish to pass on to Plots (or the next recipe).","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"compat: Compat\nWith RecipesBase 1.0 the return statement is allowed in @recipe and @series.","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"With the recipe above we can now plot Results with just","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"plot(res)","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"or","category":"page"},{"location":"syntax/#","page":"Recipe Syntax","title":"Recipe Syntax","text":"scatter(res, ε_max = 0.7, color = :green, marker = :star)","category":"page"}]
}
